\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{amsmath, amssymb, amsfonts}
\usepackage{epigraph}
\usepackage{algorithm}
\usepackage{algpseudocode}

\title{\textbf{Hopeless}\\
\vspace{0.2cm}\normalsize Relazione del progetto per il corso di Algoritmi\\
\normalsize Università di Bologna}

\author{
  E. Argonni,
  S. Musiani
}

\date{2022 - 2023}

\begin{document}

\maketitle

\vspace{1cm}
\textit{"The important thing isn't can you read music, it's can you hear it.
  Can you here the music?"}

% \newpage
% \tableofcontents
% \newpage
\vfill

\section{Introduzione}

Il progetto consisteva nello sviluppare un programma che sapesse giocare nel 
miglior modo possibile il gioco \emph{Connect X}. Quest'ultimo consiste in una
generalizzazione del classico gioco Forza 4 resa possibile da delle 
configurazioni che si distaccavano dalla classica tabella $6 \times 7$ presente 
nel gioco originale e che venivano fornite dal docente.

\section{Il giocatore Small e Big}

Se si da una veloce occhiata al codice si nota che in realtà il giocatore è 
diviso in due: Small e Big. Questa distinzione apparentemente arbitraria è 
necessaria in quanto, come spiegato più avanti nella sezione \ref{sec_bitboard},
la rappresentazione della tabella di gioco tramite Bitboard è possibile solo 
fino alla configurazione $7 \times 7$. Dove possibile quindi è stata adottata 
questa rappresentazione, mentre dove non lo era è stata mantenuta la classica
CXBoard fornita dal docente. Per questo il nome Small e Big: il gicatore Small 
può giocare solo le configurazioni più piccole della $7 \times 7$ compresa, 
mentre il giocatore Big, nonostante possa giocare tutte le configurazioni, si 
limita a quelle rimanenti.

\section{Caratteristiche generali}

Nonostante la divisione dei due giocatori in Small e Big, molti aspetti 
rimangono gli stessi tra i due. Di seguito sono quindi presentati tutti gli 
aspetti comuni ai due giocatori, lasciando per ultimi gli aspetti in cui 
differiscono.

\subsection{PVS}
Forza 4, e di conseguenza anche Connect X, è un gioco a somma-zero e a
informazione perfetta. Queste due proprietà del gioco permettono di implementare
una ricerca basata su MiniMax. Alla base di un qualsiasi giocatore artificiale
vi è infatti un algoritmo di ricerca che permette di esplorare l'albero di tutte
le mosse possibili e determinare quali sono vincenti e quali sono perdenti. In
particolare MiniMax è alla base della ricerca nei giochi a somma-zero e a
informazione perfetta.

L'algoritmo MiniMax, nonostante sia perfettamente funzionante e ritorni sempre
la mossa migliore, è particolarmente inefficiente in quanto richiede di 
esplorare l'intero albero di gioco. Questo porta a dei costi computazionali 
estremamente elevati. Prendiamo per esempio la classica configurazione di Forza 
4 con 6 righe e 7 colonne. Se volessi calcolare l'intero albero di gioco, e 
quindi tutte le possibili configurazioni che si possono ottenere, dovremmo 
considerare $3^{7 \cdot 6} = 3^{42} \approx 1.09 \cdot 10^{20}$. In realtà 
questo è un limite superiore, in quanto molte di queste configurazioni non 
sarebbero valide. Nonostante ciò le configurazioni restano comunque troppe per
essere esplorate tutte in un tempo accettabile. Sono stati quindi inventati 
degli ulteriori algoritmi, che si basano comunque su MiniMax, ma che sono molto 
più efficienti rispetto a quest'ultimo. Il più famoso è AlphaBeta. Non 
riteniamo necessario spiegare il funzionamento di MiniMax e AlphaBeta, ma bensì 
vogliamo dedicare parte di questa relazione ad illustrare la variate di 
AlphaBeta adottata nel nostro giocatore: PVS, o meglio Principal Variation 
Search.

La PVS si basa sul fatto che se esploriamo per prima la linea di gioco 
principale (la Principal Variation), o meglio quella che entrambi i giocatori 
considerano migliore, allora risulta quasi superfluo esplorare completamente 
tutte le altre possibilità di gioco in quanto dovrebbero essere peggiori a 
quella già vista. Questo però non vuol dire che non le esploriamo, ma bensì che 
la loro esplorazione è fatta in modo approssimativo in quanto non mira a 
ottenere un punteggio preciso della variante come farebbe un classico algoritmo 
AlphaBeta, ma punta a capire soltanto se la variante è migliore di quella 
considerata come principale. Se la variante è peggiore il giocatore non fa nulla 
e continua a valutare le altre varianti secondarie finché non le ha concluse, se 
invece la ricerca veloce su quella variante ha ritornato che in realtà è 
migliore della principale si esegue una ricerca completa su quella variante per 
ritornare il punteggio corretto. È necessario infatti puntualizzare che la 
ricerca veloce non restituisce il punteggio corretto associato a quella 
variante, ma soltanto se è migliore o peggiore di quella considerata come 
principale. È quindi necessario eseguire una ricerca completa per determinare il
punteggio corretto se la variante secondaria risulta essere migliore della 
principale.

Nel caso peggiore, ovvero quello in cui ogni variante secondaria risulta essere
migliore della variante principale considerata in precedenza, l'algoritmo PVS 
risulta essere più lento del classico AlphaBeta. Questo caso pessimo però è 
molto raro, sopratutto se si integra PVS un riordinamento delle mosse in modo
da considerare prima quelle che risulta essere più promettenti.

Di seguito è presentata una versione in pseudo-codice dell'algoritmo PVS:

\begin{algorithm}[H]
  \caption{\textsc{PrincipalVariationSearch}}
  \label{alg_pvs}
  \begin{algorithmic}[0]
    \Function {PVS}{$Board$, $\alpha$, $\beta$, $depth$, $color$}

      \If{$depth = 0$ \textbf{or} $node$ is a leaf}
        \State \Return $color * \Call{Evaluate}{Board}$
      \EndIf
      \\
      \State $bSearchPV \gets true$
      \For{$move$ \textbf{in} \Call{Sorted}{$Board.availableMoves()$}}
        \State $B.makeMove(move)$
        \If{$bSearchPV$}
          \Comment{\`E la \emph{Principal Variation}}
          \State $score \gets -\Call{PVS}{B, -beta, -alpha, depth - 1, \textrm{not } color}$
        \Else
          \Comment{Ricerca veloce sulle varianti secondarie}
          \State $score \gets -\Call{fastSearch}{B, -alpha, depth - 1, \textrm{not } color}$
          \If{$\alpha < score < \beta$}
            \Comment{\`E un nodo interessante}
            \State $score \gets -\Call{PVS}{B, -beta, -alpha, depth - 1, \textrm{not } color}\}$
            \State $\alpha \gets \max\{\alpha, score\}$
          \EndIf
        \EndIf
        \State $B.unamkeMove()$
        \\
        \If{$score \geq \beta$}
        \Comment{Potatura $\alpha$-$\beta$}
        \State \textbf{return} beta;
        \EndIf
        \If{$score > alpha$}
          \State $\alpha \gets score$
        \EndIf
        \State $bSearchPV \gets false$
      \EndFor
      \State \Return $alpha$
    \EndFunction

  \end{algorithmic}
\end{algorithm}

Si noti che utilizzando la proprietà di somma-zero del gioco preso in analisi, 
si può utilizzare la stessa funzione di ricerca sia per il giocatore che 
massimizza sia per il giocatore che minimizza semplicemente negando la chiamata
alla funzione successiva e invertendo $\alpha$ e $\beta$.

La ricerca principale nell'algoritmo PVS è come un normalissimo AlphaBeta se non
si considerano le ricerche veloci. La chiamata iniziale di PVS è infatti con i
parametri $\alpha$ e $\beta$ rispettivamente $-\infty$ e $+\infty$. Quello che 
però appunto distingue PVS è la ricerca veloce.

La fastSearch non è altro che un AlphaBeta modificato in modo che i parametri 
$\alpha$ e $\beta$ riducano la finestra talmente tanto da risultare quasi nulla.
Questo permette di tagliare tantissimi rami e fare in modo che la ricerca sia
effettivamente più veloce.

\begin{algorithm}
  \caption{\textsc{fastSearch}}
  \label{alg_fastSeach}
  \begin{algorithmic}
    \Function {fastSearch}{$Board$, $\beta$, $depth$, $color$}

      \If{$depth = 0$ \textbf{or} $node$ is a leaf}
        \State \Return $color * \Call{Evaluate}{Board}$
      \EndIf
      \\
      \For{$move$ \textbf{in} $Board.availableMoves()$}
        \State $B.makeMove(move)$
        \State $score \gets -\Call{fastSearch}{B, 1 - beta, depth - 1, \textrm{not } color}$
        \State $B.unamkeMove()$
        \\
        \If{$score \geq \beta$}
        \Comment{Potatura $\alpha$-$\beta$}
        \State \textbf{return} beta;
        \EndIf
      \EndFor
      \State \Return $beta - 1$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\subsection{Iterative deepening}
Il framework Iterative Deepening (ID) è una tecnica di ricerca adottata come 
metodo base per la gestione del tempo nella scelta di una mossa negli algoritmi 
che sfruttano la ricerca in profondità (Depth-First search, DFS) come PVS. 
L'idea alla base di questa strategia è quella di effettuare una serie 
di iterazioni dell'algoritmo di ricerca in profondità, aumentando gradualmente 
la profondità massima dell'albero esplorato. Ad ogni iterazione, l'algoritmo 
effettua una ricerca in profondità limitata (Depth-Limited search, DLS) e, alla
conclusione, memorizza la mossa migliore fino a quel momento trovata. 
Successivamente ricomincia la ricerca con una profondità maggiore. Questo 
procedimento continua fino a che il tempo non scade, momento in cui la mossa 
migliore fino a quel momento viene ritornata.

\begin{algorithm}
  \caption{\textsc{iterativeDeepening}}
  \label{alg_iterativeDeepening}
  \begin{algorithmic}
    \State $previousDepthSearch \gets 2$
    \Comment{Variabili globali}
    \State $currentBestMove \gets 0$
    \\
    \Function {IterativeDeepening}{$Board$}
      \State $depth \gets 2$
      \If{$amIFirst$}
        \Comment{Sono il primo giocatore}
        \State $depth \gets \Call{max}{previousDepthSearch - 2, 2}$
      \Else
        \State $depth \gets \Call{max}{previousDepthSearch - 2, 1}$ 
      \EndIf
      \\
      \State $searchNotFinished \gets true$
      \While{searchNotFinished}
        \Comment{Non ho visitato ancora tutte le foglie} 
        \State $currentBestMove \gets \Call{movePVS}{Board, depth}$
        \If{GameTree is all visited}
          \Comment{Ho visitato tutto l'albero}
          \State $searchNotFinished \gets false$
        \EndIf
        \State $previousDepthSearch \gets depth$
        \State $depth \gets depth + 2$
      \EndWhile
      \State \Return $currentBestMove$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\textsc{movePvSearch} è una variante di PVS in cui non viene ritornato il 
valore della posizione ma bensì la mossa migliore nella posizione attuale.

Si noti che nell'algoritmo presentato la profondità viene inizializzata in base 
al giocatore che inizia la partita. Inoltre l'aumento ad ogni iterazione della 
profondità non è di 1 ma bensì di 2. È necessario fare entrambe queste 
variazioni all'algoritmo generale descritto sopra per valutare solo le 
profondità in cui entrambi i giocatori hanno lo stesso numero di pedine in 
gioco. Questo è necessario perché se si valutassero profondità finali con un 
numero diverso di pedine per i due giocatori, uno di essi risulterebbe sempre in 
vantaggio. Ovviamente siamo costretti a valutare posizioni intermedie in cui il
primo giocatore avrà posizionato una pedina in più rispetto al secondo, ma 
questo non avviene nello stadio finale della ricerca in cui è necessario 
scegliere la mossa migliore.

Se il tempo massimo che il giocatore ha per eseguire una mossa scade durante
la ricerca PVS, viene ritornata immediatamente la mossa migliore che è salvata
nella variabile globale $currentBestMove$.

La variabile $previousDepthSearch$ serve per memorizzare la profondità che il
giocatore ha raggiunto nella precedente chiamata di ID. In questo modo, se nella
precedente chiamata eseguiamo una ricerca a tutte le profondità fino alla numero 
$n$, nella chiamata successiva puntiamo direttamente alla profondità $n - 2$ in 
quanto siamo praticamente certi di poterla raggiungere nel tempo dato.


\subsection{Transposition table}
\label{sec_transpositionTable}
La Transposition table (o tabella delle trasposizioni) è una strutture dati 
che memorizza le posizioni di gioco esplorate insieme alla loro valutazione. 
Questo permette di evitare di ricalcolare nuovamente la stessa posizione durante 
l'esecuzione dell'algoritmo di ricerca. Quando infatti una posizione già 
memorizzata viene ritrovata, è possibile riutilizzare la valutazione 
precedentemente calcolata, risparmiando tempo e risorse computazionali.
Nei giochi da tavolo complessi, come gli scacchi, il Go e Forza 4 il numero di 
posizioni possibili cresce esponenzialmente all'aumentare della profondità di 
ricerca. L'impiego delle tabelle di trasposizione riduce notevolmente l'overhead 
computazionale, poiché evita di ricalcolare le stesse posizioni più volte. 
Questo è per consentire l'esplorazione di alberi decisionali più profondi.

L'effettiva implementazione della Transposition table è basta sulla classe
HashTable fornita dalla libreria di Java. La posizione viene memorizzata tramite
un hash della configurazione di gioco. L'effettivo metodo di hash però 
differisce per il giocatore Small e il giocatore Big, quindi viene lasciata 
nelle rispettive sezioni la spiegazione dettagliata del metodo specifico.

Si noti che oltre alla posizione stessa è importante memorizzare la pronfodità
a cui si è valutata, perché non sempre i valori all'interno della Transposition
table sono affidabili se la profondità è più bassa di quella richiesta nella
ricerca.

\subsection{Ordine delle mosse}
Quando si devono valutare tutte le possibili mosse in una determinata posizione
è importante l'ordine con cui si decide di valutarle. L'algoritmo PVS infatti 
basa proprio il suo principio sulla valutazione della variante principale come 
prima mossa e tutte le restanti come varianti secondarie. Se infatti si 
valutasse prima la mossa peggiore, le ricerche rapide di PVS ritornerebbero un
valore maggiore di quello riscontrato sulla prima ricerca completa e, come visto 
nella sezione riguardante PVS, questo farebbe perdere tempo al giocatore. Il 
caso in cui PVS performa meglio in assoluto è quando valuta lo mossa migliore 
come prima.

La tecnica base per ottenere questo è riordinare le mosse possibili in base 
al punteggio ottenuto nell'iterazione precedente memorizzato nella Transposition
table. Se infatti l'ordine non è più quello base che considera le mosse da 
sinistra a destra, ma bensì quello in cui la mossa con il punteggio maggiore è
la prima, è molto più probabile che PVS trovi la variazione principale nalla 
prima mossa e quindi sia molto efficiente.

Nonostante a livello teorico il riordinamento delle mosse in base alla loro 
valutazione ottenuta nelle iterazioni precedenti sia il modo migliore per 
riordinare tutte le mosse se si sta utilizzando l'algoritmo PVS, a livello 
pratico il nostro giocatore non ha riscontrato nessun miglioramento. Questo 
secondo noi è dovuto a vari aspetti pratici:
\begin{enumerate}
  \item L'operazione di sorting fatta sulle mosse non è troppo dispendiosa 
    se la si considera singolarmente. Se però la si contestualizza 
    nell'algoritmo totale si scopre che in realtà viene eseguita tantissime 
    volte. Questo porta ad un rallentamento generale dell'algoritmo che non 
    riesce più ad esplorare in profondità come rispetto alla versione senza 
    questo tipo di ordinamento delle mosse.

  \item Per ordinare le mosse è necessario prima leggere i loro valori dalla 
    tabella delle trasposizioni. Per fare ciò però è necessario avere l'hash 
    relativo a ogni mossa che si vuole ordinare. Per come viene calcolato 
    l'hash \footnote{Spiegazioni più dettagliate si troveranno nella sezione
    dedicata. Per ora è necessario soltanto puntualizzare che l'obbligo di 
    eseguire una mossa sulla board per sapere l'hash della posizione è legato
    soltanto alle board piccole ($\leq 7 \times 7$) e non a quelle grandi 
    ($\geq 20 \times 20$). Nonostante ciò nelle board grandi il costo di 
    ordinamento di tutte le mosse è molto maggiore risultando comunque in un
    peggioramento} però è necessario eseguire ogni mossa singolarmente per 
    ottenerlo e poi annullarla. Questo porta a eseguire e ad annullare ogni 
    mossa almeno due volte: la prima quando si ordinano le mosse disponibili e 
    la seconda quando una board. 

  \item Infine la nostra euristica non è sicuramente accurata abbastanza da 
    assegnare in modo sistematico il valore migliore alla linea principale di 
    gioco. È quindi probabile che anche con le mosse riordinate la PVS non sia
    comunque tra le prime, risultando in un rallentamento.
\end{enumerate}

La soluzione adottata per evitare di ordinare le mosse in ordine di valutazione
è stata quella di ordinarle rispetto alla loro posizione relativa al centro: 
mosse più vicine al centro vengono valutate prima di mosse lontane da esso.
L'algoritmo è quindi il seguente:

\begin{algorithm}
  \caption{\textsc{reorderMoves}}
 \begin{algorithmic}
   \Function{reorderMoves}{$Board$}
   \State $possibleMoves[] \gets Board.getPossibleMoves()$
     \Comment{Le mosse sono ordinate da sinistra a destra}
     \State $l \gets possibleMoves.length$
     \State $orderedMoves[]$ is an array of length $l$
     \State $delta \gets 0$
     \\
     \For{$i \gets 0$ \textbf{to} $i < l$ \textbf{step} $i \gets i + 1$}
       \If{$i$ is odd}
         \State $delta \gets delta + 1$

         \State $orderedMoves[i] \gets possibleMoves[l / 2 - delta]$
       \Else
         \State $orderedMoves[i] \gets possibleMoves[l / 2 + delta]$
       \EndIf
     \EndFor

     \State \Return $orderedMoves[]$
   \EndFunction
 \end{algorithmic} 
\end{algorithm}

\subsection{Euristica}
\subsubsection{Come viene valutata una posizione}
\subsubsection{Euristica incrementale}
\subsubsection{Miglioramenti riscontrati}
\subsubsection{Ammortizzazione e valori quadratici}

\section{Bitboard in Small}
\label{sec_bitboard}
La vera differenza tra il gicatore Big e il giocatore Small e il modo in cui
viene rappresentata una configurazione di gioco. Il metodo sicuramente più
intuitivo per rappresentare una posizione di Forza 4 è quello di impegare una 
matrice in cui ogni cella è direttamente associata ad una cesella della 
posizione e i valori della matrice indicano se una determinata cella è vuota, 
è presente una pedina del primo giocatore o è presente una pedina del secondo 
giocatore.

Questo metodo ovviamente funziona ed è anche molto semplice da implementare. La
classe fornita dal docente che si occupava delle configurazioni di gioco 
utilizza infatti una matrice. Il problema della rappresentazione tramite matrice
sorge quando si deve valutare se un determinato giocatore ha vinto. Per vincere
in Connect X bisogna allineare esattamente \emph{X} pedine in verticale, 
orizzontale o diagonale. Quindi il controllo consiste nel guardare tutte le 
colonne, tutte le righe e infine tutte le diagonali per scoprire se un giocatore
è riuscito ad allineare \emph{X} pedine. Questo controllo fa eseguito ogni volta
che un giocatore esegue una mossa, risultando quindi estremamente dispendioso.
Nella classe CXBoard è però presente un'ottimizzazione: essendo il controllo 
eseguito per ogni singola mossa giocata, non è necessario controllare tutte le
righe, colonne e diagonali della posizione, ma soltanto quelle interessate 
dall'ultima mossa.

Esiste però un modo per rappresentare tutte le configurazioni di gioco tramite
due interi a 64 bit e controllare se un giocatore ha vinto senza l'utilizzo di
loop e solo grazie alle operazioni tra bit.

\subsection{Funzionamento}
Rappresentiamo un board di dimensioni $M \times N$ tramite due interi a 64 bit
che chiameremo \emph{position} e \emph{mask}. L'idea è quella di associare ogni
singola cella di una posizione ad un bit della \emph{position} e ad un bit della
\emph{mask}. Prendiamo la classica tabella di Forza 4 che ha dimensioni $M = 6$ 
e $N = 7$.

\begin{center}
  INSERIRE IMMAGINE
\end{center}
Ad ogni cella corrisponde il numero del bit indicato. L'intero \emph{position} 
memorizza la posizione del giocatore che dovrà fare la prossima mossa. In 
particolare avrà uguale a 1 tutti i bit in cui è presente una sua pedina e a 0
tutti quelli in cui vi è una pedina dell'avversario o non vi è nessuna pedina. 
L'intero \emph{mask} memorizza invece le pedine occupate indipendentemente dal
giocatore. In particolare se celle sono vuote i bit corrispondenti saranno a 0, 
mentre se le celle contengono una pedina i bit corrispondenti saranno a 1. 
Vale quindi che quando tutte le celle sono vuote $position = 0$ e $mask = 0$. Se 
volessimo rappresentare la seguente posizione:
\begin{center}
  INSERIRE IMMAGINE
\end{center}
Bit e mask assumerebbero questi valori:\medskip
\begin{center}
  INSERIRE BIT
\end{center}

Se si vuole ottenere la posizione del giocatore avversario basta eseguire uno
XOR tra i bit della \emph{position} e i bit della \emph{mask}. La posizione
dell'avversario come mostrato in figura infatti risulta essere:
\begin{center}
  INSERIRE BIT
\end{center}
Si noti come alcuni numeri sono mancati, come se ci fosse una riga fantasma 
sopra a quelle visibili. Più avanti verrà spiegato perché è necessario 
utilizzare una riga in più per la rappresentazione.


\subsection{Fare una mossa e annullarla}
Se avessimo usato una semplice matrice per la rappresentazione di una posizione
di gioco, le mosse dei giocatori sarebbero state effettivamente semplici da
memorizzare: bastava infatti modificare la cella della matrice associata. 
Utilizzando però la rappresentazione tramite bit, l'operazione di giocare una
pedina è leggermente più complicata. 

Innanzitutto ci ricordiamo che la variabile \emph{position} rappresenta la 
configurazione del giocatore che dovrà giocare la prossima mossa, mentre la 
variabile \emph{mask} rappresenta le pedine sulla board. Quando un giocatore
decide di fare una mossa le operazioni che vengono eseguite per memorizzarla
sono quelle rappresentate nel seguente speudo-codice.

\begin{algorithm}
  \caption{\textsc{MarkColumn}}
  \begin{algorithmic}
    \Function{markColumn}{$col$}
      \State $position \gets position \oplus mask$
      \State $mask \gets mask | (mask + (1 \ll (col * (Rows + 1))))$
      \\
      \If{\Call{isWinningMove}{}}
        \If{next to play is Player 2}
          \State $gameState \gets $ first player win
        \Else
          \State $gameState \gets $ second player win 
        \EndIf
      \ElsIf{the board if full}
          \State $gameState \gets $ draw
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}

Riteniamo che sia necessario dare una spiegazione dei simboli usati:
\begin{itemize}
  \item $\oplus$ è il simbolo di XOR tra bit.
  \item $|$ è il simbolo di OR tra bit.
  \item $\ll$ è il simbolo di shift a sinistra tra bit.
  \item $*$ è il simbolo di moltiplicazione tra numeri interi.
  \item $+$ è il simbolo di somma tra numeri interi.
\end{itemize}
Analizziamo quindi le operazioni sequenzialmente: la prima riga mostra come
venga fatta l'operazione di XOR tra la $position$ e la $mask$. Questo, come già
spiegato in precedenza, permette di ottenere la posizione dell'avversario. 
Nonostante quindi la mossa del giocatore corrente non sia ancora stata segnata, 
la variabile $position$ viene portata a indicare la posizione del giocatore che 
deve muovere al prossimo turno. Avviene quindi nella seconda riga la 
memorizzazione della mossa. Essendo ora la variabile $position$ modificata per
indicare la posizione dell'avversario, è soltanto necessario inserire la mossa
fatta nella $mask$, in quanto è l'unica a memorizzare le posizione di entrambi i 
giocatori. Per fare ciò si sposa un singolo bit fino alla cella base della 
colonna giocata: $1 \ll (col * (Rows + 1)))$, e successivamente lo si somma con
la maschera: $mask + (1 \ll (col * (Rows + 1))))$. In questo modo, essendo i
bit ordiati in senso crescente rispetto alle righe, il bit sommato alla base 
della collona viene "propagato" fino alla prima cella libera di tale colonne, 
dove quindi il giocatore avrà fatto la sua mossa. Durante la "propagazione" del
bit però, alcune celle potrebbero diventare nulle in quanto in binario $1 + 1 = 
10$. È quindi necessario sovrascrivere quelle celle eseguendo un OR tra la 
$mask$ originale e quella derivata dalla somma con il bit. Facciamo un esempio:
\begin{center}
  INSERIRE BIT ESEMPIO
\end{center}

Quando invece si vuole annullare l'ultima mossa giocata vengono eseguite operazioni
estremamente simili, solo nell'ordine inverso. In particolare le due operazioni
chiave sono:

\begin{align*}
  &mask = mask \oplus (1 \ll ((Rows + 1) * col + row))\\
  &position = position \oplus mask;
\end{align*}
Nella prima riga viene riportato a 0 il bit riguardo la mossa appena giocata,
mentre nella seconda viene riportata la posizione al giocatore precedente, 
quello cioè che ha annullato la mossa. Si noti che $Rows$ è il numero di colonne
totali nella board, mentre $col$ e $row$ sono rispettivamente la colonna e la
riga in cui l'ultima mossa è stata giocata.

\subsection{Valutazione di una vittoria}
\subsection{Controllo di una casella specifica}
\subsection{Hash di una posizione}
\subsection{Miglioramenti riscontrati}

\section{Zobrist: hash per Big}

\section{Possibili miglioramenti}
\section{Conclusione}

\end{document}

